//
//  {{toneburst.name}}.swift
//
//

import Foundation

import Chord
import Datable
import Ghostwriter
import ReplicantSwift
import TransmissionAsync

public enum {{toneburst.name}}Mode: String, Codable
{
    {% for mode in toneburst.modes %}case {{mode.name}}
    {% endfor %}
}

public class {{toneburst.name}}: ToneBurst, Codable
{
    public var type: ReplicantSwift.ToneBurstType = .starburst
    
    let mode: {{toneburst.name}}Mode

    public init(_ mode: {{toneburst.name}}Mode)
    {
        self.mode = mode
    }

    public func perform(connection: TransmissionAsync.AsyncConnection) async throws
    {
        let instance = {{toneburst.name}}Instance(self.mode, connection)
        try await instance.perform()
    }
}

public struct {{toneburst.name}}Instance
{
    let connection: TransmissionAsync.AsyncConnection
    let mode: {{toneburst.name}}Mode

    public init(_ mode: {{toneburst.name}}Mode, _ connection: TransmissionAsync.AsyncConnection)
    {
        self.mode = mode
        self.connection = connection
    }

    public func perform() async throws
    {
        switch mode
        {
            {% for mode in toneburst.modes %}
            case .{{mode.name}}:
                try await handle{{mode.name}}()
            {% endfor %}
        }
    }
    
    func listen(structuredText: StructuredText, maxSize: Int = 255, timeout: Duration = .seconds(60)) async throws -> MatchResult
    {
        let listenTask: Task<MatchResult?, Error> = Task {
            var buffer = Data()
            while buffer.count < maxSize
            {
                do {
                    let byte = try await connection.readSize(1)
                    
                    buffer.append(byte)
                    
                    guard let string = String(data: buffer, encoding: .utf8) else
                    {
                        // This could fail because we're in the middle of a UTF8 rune.
                        continue
                    }
                    
                    do
                    {
                        return try structuredText.match(string: string)
                    }
                    catch
                    {
                        continue
                    }
                } catch {
                    return nil
                }
            }
            
            return nil
        }
        
        let _ = Task {
            try await Task.sleep(for: timeout)
            listenTask.cancel()
        }
        
        do {
            guard let result = try await listenTask.value else {
                throw StarburstError.readFailed
            }
            return result
        } catch {
            throw StarburstError.timeout
        }
    }
    
    func speak(structuredText: StructuredText) async throws
    {
        do
        {
            let string = structuredText.string
            try await connection.writeString(string: string)
        }
        catch
        {
            print(error)
            throw StarburstError.writeFailed
        }
    }
    
{% for mode in toneburst.modes %}
{{mode.function}}
{% endfor %}
}

public enum {{toneburst.name}}Error: Error
{
    case timeout
    case connectionClosed
    case writeFailed
    case readFailed
    case listenFailed
    case speakFailed
    case maxSizeReached
}
